---
layout:     post   				    # 使用的布局（不需要改）
title:      蓝桥杯备战(二) 				# 标题 
subtitle:   lanqiao每日一题    #副标题
date:       2024-03-16 				# 时间
author:     Scorpio 						# 作者
header-img: img/post-bg-lanqiao.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - c++
    - 算法
    - 程序设计
---
## Hey
>每日一算法备战蓝桥杯。

<font color='red'>注意数据范围是否需要开longlong</font>

# 1. DFS(深度优先搜索算法)
>深度优先搜索的步骤分为 1.递归下去 2.回溯上来。顾名思义，深度优先，则是以深度为准则，先一条路走到底，直到达到目标。这里称之为递归下去。  
>2024-03-16  

在实际的操作中，我们一般对深度优先搜索问题进行分类：

- 定义的DFS：对图的连通性进行测试，典型的问题：迷宫连通性测试、图的条件搜索等
- 广义的DFS–DFS思路的应用：DFS搜索顺序+规则问题、穷举结果寻求最优解/符合条件解等等，由于其穷举答案的本质，又被称为爆搜

```
function dfs(当前状态, 一系列其他的状态量){
	if(当前状态 == 目的状态){
        ···
    }
    for(···寻找新状态){
        if(状态合法){
            vis[访问该点]；
            dfs(新状态);
            ?是否需要恢复现场->vis[恢复访问]
        } 
    }
    if(找不到新状态){
        是否需要创建新规则？{
            创建并对当前状态进行访问vis;
            继续搜索;
            恢复现场/恢复访问vis;
        }
    }
}
```


# 2. 回溯
>「回溯是递归的副产品，只要有递归就会有回溯」，所以回溯法也经常和二叉树遍历，深度优先搜索混在一起，因为这两种方式都是用了递归。
回溯法就是暴力搜索，并不是什么高效的算法，最多再剪枝一下。  
>2024-03-19  

回溯算法能解决如下问题：

- 组合问题：N个数里面按一定规则找出k个数的集合
- 排列问题：N个数按一定规则全排列，有几种排列方式
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个N个数的集合里有多少符合条件的子集
- 棋盘问题：N皇后，解数独等等


# 3. BFS(广度优先搜索算法)
>广度优先搜索较之深度优先搜索之不同在于，深度优先搜索旨在不管有多少条岔路，先一条路走到底，不成功就返回上一个路口然后就选择下一条岔路，而广度优先搜索旨在面临一个路口时，把所有的岔路口都记下来，然后选择其中一个进入，然后将它的分路情况记录下来，然后再返回来进入另外一个岔路，并重复这样的操作。  
>2024-03-20  

广度优先搜索的优点：

- 可以寻找记录最短路径

- 不会爆栈


深度优先搜索的优点：

- 代码短

- 对于内存消耗小（不需要开队列） 


```
struct Node
{
	int x,y,d;
};
int w[N][N];
int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
bool st[N][N]; 
queue<Node>	q;

void bfs()
{
	q.push({0,0,0});
	st[0][0]=true;
	
	while(q.size())
	{
		auto t=q.front();
		q.pop();
		
		for(int i=0;i<4;i++)
		{
			int xx=dx[i]+t.x,yy=dy[i]+t.y;
			
			if(xx<0||xx>=n||yy<0||yy>=m)	continue;
			if(st[xx][yy])	continue;
			if(w[xx][yy]=='.')	continue;

			if(xx==n-1&&yy==m-1)
			{
				res=t.d+1;
				return ;
			}
			st[xx][yy]=true;
			q.push({xx,yy,t.d+1});
		}
	}	
}
```


# 4. Flood Fill（洪水灌溉算法）
>可以在线性的时间复杂内，找到某个点所在的连通块！
>从一个起始节点开始把附近与其连通的节点提取出或填充成不同颜色颜色，直到封闭区域内的所有节点都被处理过为止，是从一个区域中提取若干个连通的点与其他相邻区域区分开(或分别染成不同颜色)的经典算法。  
>2024-03-20  

洪水填充算法实现最常见有四邻域填充法(不考虑对角线方向的节点)，八邻域填充法(考虑对角线方向的节点)，基于扫描线填充方法。

```
void dfs(int x,int y)
{
	int t=g[x][y];
	g[x][y]=-2;
	
	//t有值的话就是灌溉到边界了 
	if(t)	return ;
	
	for(int i=x-1;i<=x+1;i++)
		for(int j=y-1;j<=y+1;j++)
			if(i>=0&&i<n&&j>=0&&j<n&&g[i][j]>=0)
				dfs(i,j);
}
```

# 5. 并查集
>并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题（即所谓的并、查）。  
>时间复杂度： $O(1)$  
>2024-03-21  

并查集是最简洁而优雅的数据结构之一，主要用于解决一些元素分组的问题。它管理一系列不相交的集合，并支持两种操作：

- 合并（Union）：把两个不相交的集合合并为一个集合。
- 查询（Find）：查询两个元素是否在同一个集合中。

```
//同时实现并查操作
int find(int x)
{
	if(p[x]!=x)	p[x]=find(p[x]);
	return p[x];
}
```
