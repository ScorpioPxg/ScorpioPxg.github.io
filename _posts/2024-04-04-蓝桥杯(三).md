---
layout:     post   				    # 使用的布局（不需要改）
title:      蓝桥杯备战(三) 				# 标题 
subtitle:   AcWing每日一题    #副标题
date:       2024-04-04 				# 时间
author:     Scorpio 						# 作者
header-img: img/post-bg-lanqiao.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - c++
    - 算法
    - 程序设计
---
## Hey
>每日一算法备战蓝桥杯。

<font color='red'>注意数据范围是否需要开longlong</font>

<font color='red'>memset 只能设置0和-1</font>

<font color='red'>计算过程中会mod，相减之后可能会小于0 ，需要+mod再进行一次mod操作</font>

<font color='red'>容斥原理：用全部的方案数减去相反的方案数</font>

# 1. 快速幂
>可以快速进行乘方运算
>
>时间复杂度：O(logb)
>
>2024-04-04  


```
//a的b次对p取模
int qmi(int a,int b,int p)
{
	int res=1;
	while(b)
	{
		if(b&1)	res=(ll)res*a%p;
		a=(ll)a*a%p;
		b>>=1;
	}
	return res;
}
```

# 2. 最大公约数
>2024-04-04  

```
int gcd(int a,int b)
{
    return b ? gcd(b,a%b) : a; 
}
```

# 3. 最大公约数分解质因数
>一个数的因数中如果是质数，那么就说这个数是这个数的质因数
>
>算术基本定理：任何一个大于1的自然数 N,如果N不为质数，那么N可以唯一分解成有限个质数的乘积
>
>时间复杂度：O(sqrt(n))
>
>2024-04-05 

```
void divide(int x)
{
    for(int i=2;i<=x/i;i++)
        if(x%i==0)
        {
            int s=0;
            while(x%i==0)   x/=i,s++;
            cout<<i<<' '<<s<<endl;
        }
    if(x>1)   cout<<x<<' '<<1<<endl;
    cout<<endl;
}
```


# 4. 矩阵乘法
>矩阵的n次相乘可以转换成快速幂 
>
>时间复杂度：O(sqrt(n))
>
>2024-04-06 


斐波那契的迭代可以转换成矩阵乘法 

类似的迭代问题[AcWing.1217垒骰子](https://www.acwing.com/problem/content/1219/)



```
//矩阵乘法
void mul(int a[][2],int b[][2])
{
    int c[2][2]={0};

    for(int i=0;i<2;i++)
        for(int j=0;j<2;j++)
            for(int k=0;k<2;k++)
                c[i][j]=(c[i][j]+a[i][k]*b[k][j])%mod;
    memcpy(a,c,sizeof c);
 }

//矩阵乘法快速幂
int qmi(int n)
{
    int a[2][2]={
        {0,1},
        {0,0}
    };
    int f[2][2]={0,1,1,1};
    while(n)
    {
        if(n&1) mul(a,f);
        mul(f,f);
        n>>=1;
    }
    return a[0][0];
}
```
